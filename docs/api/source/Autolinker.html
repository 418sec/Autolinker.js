<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
var utils_1 = require(&quot;./utils&quot;);
var anchor_tag_builder_1 = require(&quot;./anchor-tag-builder&quot;);
var html_parser_1 = require(&quot;./htmlParser/html-parser&quot;);
var match_1 = require(&quot;./match/match&quot;);
var email_match_1 = require(&quot;./match/email-match&quot;);
var hashtag_match_1 = require(&quot;./match/hashtag-match&quot;);
var mention_match_1 = require(&quot;./match/mention-match&quot;);
var phone_match_1 = require(&quot;./match/phone-match&quot;);
var url_match_1 = require(&quot;./match/url-match&quot;);
var matcher_1 = require(&quot;./matcher/matcher&quot;);
var html_tag_1 = require(&quot;./html-tag&quot;);
var email_matcher_1 = require(&quot;./matcher/email-matcher&quot;);
var url_matcher_1 = require(&quot;./matcher/url-matcher&quot;);
var hashtag_matcher_1 = require(&quot;./matcher/hashtag-matcher&quot;);
var phone_matcher_1 = require(&quot;./matcher/phone-matcher&quot;);
var mention_matcher_1 = require(&quot;./matcher/mention-matcher&quot;);
<span id='Autolinker-method-constructor'><span id='Autolinker'>/**
</span></span> * @class Autolinker
 * @extends Object
 *
 * Utility class used to process a given string of text, and wrap the matches in
 * the appropriate anchor (&amp;lt;a&amp;gt;) tags to turn them into links.
 *
 * Any of the configuration options may be provided in an Object (map) provided
 * to the Autolinker constructor, which will configure how the {@link #link link()}
 * method will process the links.
 *
 * For example:
 *
 *     var autolinker = new Autolinker( {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *
 *     var html = autolinker.link( &quot;Joe went to www.yahoo.com&quot; );
 *     // produces: &#39;Joe went to &lt;a href=&quot;http://www.yahoo.com&quot;&gt;yahoo.com&lt;/a&gt;&#39;
 *
 *
 * The {@link #static-link static link()} method may also be used to inline
 * options into a single call, which may be more convenient for one-off uses.
 * For example:
 *
 *     var html = Autolinker.link( &quot;Joe went to www.yahoo.com&quot;, {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     // produces: &#39;Joe went to &lt;a href=&quot;http://www.yahoo.com&quot;&gt;yahoo.com&lt;/a&gt;&#39;
 *
 *
 * ## Custom Replacements of Links
 *
 * If the configuration options do not provide enough flexibility, a {@link #replaceFn}
 * may be provided to fully customize the output of Autolinker. This function is
 * called once for each URL/Email/Phone#/Hashtag/Mention (Twitter, Instagram, Soundcloud)
 * match that is encountered.
 *
 * For example:
 *
 *     var input = &quot;...&quot;;  // string with URLs, Email Addresses, Phone #s, Hashtags, and Mentions (Twitter, Instagram, Soundcloud)
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( match ) {
 *             console.log( &quot;href = &quot;, match.getAnchorHref() );
 *             console.log( &quot;text = &quot;, match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case &#39;url&#39; :
 *                     console.log( &quot;url: &quot;, match.getUrl() );
 *
 *                     if( match.getUrl().indexOf( &#39;mysite.com&#39; ) === -1 ) {
 *                         var tag = match.buildTag();  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
 *                         tag.setAttr( &#39;rel&#39;, &#39;nofollow&#39; );
 *                         tag.addClass( &#39;external-link&#39; );
 *
 *                         return tag;
 *
 *                     } else {
 *                         return true;  // let Autolinker perform its normal anchor tag replacement
 *                     }
 *
 *                 case &#39;email&#39; :
 *                     var email = match.getEmail();
 *                     console.log( &quot;email: &quot;, email );
 *
 *                     if( email === &quot;my@own.address&quot; ) {
 *                         return false;  // don&#39;t auto-link this particular email address; leave as-is
 *                     } else {
 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
 *                     }
 *
 *                 case &#39;phone&#39; :
 *                     var phoneNumber = match.getPhoneNumber();
 *                     console.log( phoneNumber );
 *
 *                     return &#39;&lt;a href=&quot;http://newplace.to.link.phone.numbers.to/&quot;&gt;&#39; + phoneNumber + &#39;&lt;/a&gt;&#39;;
 *
 *                 case &#39;hashtag&#39; :
 *                     var hashtag = match.getHashtag();
 *                     console.log( hashtag );
 *
 *                     return &#39;&lt;a href=&quot;http://newplace.to.link.hashtag.handles.to/&quot;&gt;&#39; + hashtag + &#39;&lt;/a&gt;&#39;;
 *
 *                 case &#39;mention&#39; :
 *                     var mention = match.getMention();
 *                     console.log( mention );
 *
 *                     return &#39;&lt;a href=&quot;http://newplace.to.link.mention.to/&quot;&gt;&#39; + mention + &#39;&lt;/a&gt;&#39;;
 *             }
 *         }
 *     } );
 *
 *
 * The function may return the following values:
 *
 * - `true` (Boolean): Allow Autolinker to replace the match as it normally
 *   would.
 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
 * - Any String: If a string is returned from the function, the string will be
 *   used directly as the replacement HTML for the match.
 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify
 *   an HTML tag before writing out its HTML text.
 *
 * @constructor
 * @param {Object} [cfg] The configuration options for the Autolinker instance,
 *   specified in an Object (map).
 */
var Autolinker =  (function () {
    function Autolinker(cfg) {
        if (cfg === void 0) { cfg = {}; }
<span id='Autolinker-property-version'>        /**
</span>         * The Autolinker version number exposed on the instance itself.
         *
         * Ex: 0.25.1
         */
        this.version = Autolinker.version;
        this.urls = this.normalizeUrlsCfg(cfg.urls);
        this.email = typeof cfg.email === &#39;boolean&#39; ? cfg.email : true;
        this.phone = typeof cfg.phone === &#39;boolean&#39; ? cfg.phone : true;
        this.hashtag = cfg.hashtag || false;
        this.mention = cfg.mention || false;
        this.newWindow = typeof cfg.newWindow === &#39;boolean&#39; ? cfg.newWindow : true;
        this.stripPrefix = this.normalizeStripPrefixCfg(cfg.stripPrefix);
        this.stripTrailingSlash = typeof cfg.stripTrailingSlash === &#39;boolean&#39; ? cfg.stripTrailingSlash : true;
        this.decodePercentEncoding = typeof cfg.decodePercentEncoding === &#39;boolean&#39; ? cfg.decodePercentEncoding : true;
        // Validate the value of the `mention` cfg
        var mention = this.mention;
        if (mention !== false &amp;&amp; mention !== &#39;twitter&#39; &amp;&amp; mention !== &#39;instagram&#39;) {
            throw new Error(&quot;invalid `mention` cfg - see docs&quot;);
        }
        // Validate the value of the `hashtag` cfg
        var hashtag = this.hashtag;
        if (hashtag !== false &amp;&amp; hashtag !== &#39;twitter&#39; &amp;&amp; hashtag !== &#39;facebook&#39; &amp;&amp; hashtag !== &#39;instagram&#39;) {
            throw new Error(&quot;invalid `hashtag` cfg - see docs&quot;);
        }
        this.truncate = this.normalizeTruncateCfg(cfg.truncate);
        this.className = cfg.className || &#39;&#39;;
        this.replaceFn = cfg.replaceFn || null;
        this.context = cfg.context || this;
        this.htmlParser = new html_parser_1.HtmlParser();
        this.matchers = null;
        this.tagBuilder = null;
    }
<span id='Autolinker-static-method-link'>    /**
</span>     * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,
     * Hashtags, and Mentions found in the given chunk of HTML. Does not link URLs
     * found within HTML tags.
     *
     * For instance, if given the text: `You should go to http://www.yahoo.com`,
     * then the result will be `You should go to &amp;lt;a href=&quot;http://www.yahoo.com&quot;&amp;gt;http://www.yahoo.com&amp;lt;/a&amp;gt;`
     *
     * Example:
     *
     *     var linkedText = Autolinker.link( &quot;Go to google.com&quot;, { newWindow: false } );
     *     // Produces: &quot;Go to &lt;a href=&quot;http://google.com&quot;&gt;google.com&lt;/a&gt;&quot;
     *
     * @static
     * @param {String} textOrHtml The HTML or text to find matches within (depending
     *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #mention},
     *   {@link #hashtag}, and {@link #mention} options are enabled).
     * @param {Object} [options] Any of the configuration options for the Autolinker
     *   class, specified in an Object (map). See the class description for an
     *   example call.
     * @return {String} The HTML text, with matches automatically linked.
     */
    Autolinker.link = function (textOrHtml, options) {
        var autolinker = new Autolinker(options);
        return autolinker.link(textOrHtml);
    };
<span id='Autolinker-static-method-parse'>    /**
</span>     * Parses the input `textOrHtml` looking for URLs, email addresses, phone
     * numbers, username handles, and hashtags (depending on the configuration
     * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
     * objects describing those matches (without making any replacements).
     *
     * Note that if parsing multiple pieces of text, it is slightly more efficient
     * to create an Autolinker instance, and use the instance-level {@link #parse}
     * method.
     *
     * Example:
     *
     *     var matches = Autolinker.parse( &quot;Hello google.com, I am asdf@asdf.com&quot;, {
     *         urls: true,
     *         email: true
     *     } );
     *
     *     console.log( matches.length );           // 2
     *     console.log( matches[ 0 ].getType() );   // &#39;url&#39;
     *     console.log( matches[ 0 ].getUrl() );    // &#39;google.com&#39;
     *     console.log( matches[ 1 ].getType() );   // &#39;email&#39;
     *     console.log( matches[ 1 ].getEmail() );  // &#39;asdf@asdf.com&#39;
     *
     * @static
     * @param {String} textOrHtml The HTML or text to find matches within
     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
     *   {@link #hashtag}, and {@link #mention} options are enabled).
     * @param {Object} [options] Any of the configuration options for the Autolinker
     *   class, specified in an Object (map). See the class description for an
     *   example call.
     * @return {Autolinker.match.Match[]} The array of Matches found in the
     *   given input `textOrHtml`.
     */
    Autolinker.parse = function (textOrHtml, options) {
        var autolinker = new Autolinker(options);
        return autolinker.parse(textOrHtml);
    };
<span id='Autolinker-method-normalizeUrlsCfg'>    /**
</span>     * Normalizes the {@link #urls} config into an Object with 3 properties:
     * `schemeMatches`, `wwwMatches`, and `tldMatches`, all Booleans.
     *
     * See {@link #urls} config for details.
     *
     * @param {Boolean/Object} urls
     * @return {Object}
     */
    Autolinker.prototype.normalizeUrlsCfg = function (urls) {
        if (urls == null)
            urls = true; // default to `true`
        if (typeof urls === &#39;boolean&#39;) {
            return { schemeMatches: urls, wwwMatches: urls, tldMatches: urls };
        }
        else { // object form
            return {
                schemeMatches: typeof urls.schemeMatches === &#39;boolean&#39; ? urls.schemeMatches : true,
                wwwMatches: typeof urls.wwwMatches === &#39;boolean&#39; ? urls.wwwMatches : true,
                tldMatches: typeof urls.tldMatches === &#39;boolean&#39; ? urls.tldMatches : true
            };
        }
    };
<span id='Autolinker-method-normalizeStripPrefixCfg'>    /**
</span>     * Normalizes the {@link #stripPrefix} config into an Object with 2
     * properties: `scheme`, and `www` - both Booleans.
     *
     * See {@link #stripPrefix} config for details.
     *
     * @private
     * @param {Boolean/Object} stripPrefix
     * @return {Object}
     */
    Autolinker.prototype.normalizeStripPrefixCfg = function (stripPrefix) {
        if (stripPrefix == null)
            stripPrefix = true; // default to `true`
        if (typeof stripPrefix === &#39;boolean&#39;) {
            return { scheme: stripPrefix, www: stripPrefix };
        }
        else { // object form
            return {
                scheme: typeof stripPrefix.scheme === &#39;boolean&#39; ? stripPrefix.scheme : true,
                www: typeof stripPrefix.www === &#39;boolean&#39; ? stripPrefix.www : true
            };
        }
    };
<span id='Autolinker-method-normalizeTruncateCfg'>    /**
</span>     * Normalizes the {@link #truncate} config into an Object with 2 properties:
     * `length` (Number), and `location` (String).
     *
     * See {@link #truncate} config for details.
     *
     * @private
     * @param {Number/Object} truncate
     * @return {Object}
     */
    Autolinker.prototype.normalizeTruncateCfg = function (truncate) {
        if (typeof truncate === &#39;number&#39;) {
            return { length: truncate, location: &#39;end&#39; };
        }
        else { // object, or undefined/null
            return utils_1.defaults(truncate || {}, {
                length: Number.POSITIVE_INFINITY,
                location: &#39;end&#39;
            });
        }
    };
<span id='Autolinker-method-parse'>    /**
</span>     * Parses the input `textOrHtml` looking for URLs, email addresses, phone
     * numbers, username handles, and hashtags (depending on the configuration
     * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
     * objects describing those matches (without making any replacements).
     *
     * This method is used by the {@link #link} method, but can also be used to
     * simply do parsing of the input in order to discover what kinds of links
     * there are and how many.
     *
     * Example usage:
     *
     *     var autolinker = new Autolinker( {
     *         urls: true,
     *         email: true
     *     } );
     *
     *     var matches = autolinker.parse( &quot;Hello google.com, I am asdf@asdf.com&quot; );
     *
     *     console.log( matches.length );           // 2
     *     console.log( matches[ 0 ].getType() );   // &#39;url&#39;
     *     console.log( matches[ 0 ].getUrl() );    // &#39;google.com&#39;
     *     console.log( matches[ 1 ].getType() );   // &#39;email&#39;
     *     console.log( matches[ 1 ].getEmail() );  // &#39;asdf@asdf.com&#39;
     *
     * @param {String} textOrHtml The HTML or text to find matches within
     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
     *   {@link #hashtag}, and {@link #mention} options are enabled).
     * @return {Autolinker.match.Match[]} The array of Matches found in the
     *   given input `textOrHtml`.
     */
    Autolinker.prototype.parse = function (textOrHtml) {
        var htmlNodes = this.htmlParser.parse(textOrHtml), anchorTagStackCount = 0, // used to only process text around anchor tags, and any inner text/html they may have;
        matches = [];
        // Find all matches within the `textOrHtml` (but not matches that are
        // already nested within &lt;a&gt;, &lt;style&gt; and &lt;script&gt; tags)
        for (var i = 0, len = htmlNodes.length; i &lt; len; i++) {
            var node = htmlNodes[i], nodeType = node.getType();
            if (nodeType === &#39;element&#39; &amp;&amp; [&#39;a&#39;, &#39;style&#39;, &#39;script&#39;].indexOf(node.getTagName()) !== -1) { // Process HTML anchor, style and script element nodes in the input `textOrHtml` to find out when we&#39;re within an &lt;a&gt;, &lt;style&gt; or &lt;script&gt; tag
                if (!node.isClosing()) { // it&#39;s the start &lt;a&gt;, &lt;style&gt; or &lt;script&gt; tag
                    anchorTagStackCount++;
                }
                else { // it&#39;s the end &lt;/a&gt;, &lt;/style&gt; or &lt;/script&gt; tag
                    anchorTagStackCount = Math.max(anchorTagStackCount - 1, 0); // attempt to handle extraneous &lt;/a&gt; tags by making sure the stack count never goes below 0
                }
            }
            else if (nodeType === &#39;text&#39; &amp;&amp; anchorTagStackCount === 0) { // Process text nodes that are not within an &lt;a&gt;, &lt;style&gt; and &lt;script&gt; tag
                var textNodeMatches = this.parseText(node.getText(), node.getOffset());
                matches.push.apply(matches, textNodeMatches);
            }
        }
        // After we have found all matches, remove subsequent matches that
        // overlap with a previous match. This can happen for instance with URLs,
        // where the url &#39;google.com/#link&#39; would match &#39;#link&#39; as a hashtag.
        matches = this.compactMatches(matches);
        // And finally, remove matches for match types that have been turned
        // off. We needed to have all match types turned on initially so that
        // things like hashtags could be filtered out if they were really just
        // part of a URL match (for instance, as a named anchor).
        matches = this.removeUnwantedMatches(matches);
        return matches;
    };
<span id='Autolinker-method-compactMatches'>    /**
</span>     * After we have found all matches, we need to remove matches that overlap
     * with a previous match. This can happen for instance with URLs, where the
     * url &#39;google.com/#link&#39; would match &#39;#link&#39; as a hashtag. Because the
     * &#39;#link&#39; part is contained in a larger match that comes before the HashTag
     * match, we&#39;ll remove the HashTag match.
     *
     * @private
     * @param {Autolinker.match.Match[]} matches
     * @return {Autolinker.match.Match[]}
     */
    Autolinker.prototype.compactMatches = function (matches) {
        // First, the matches need to be sorted in order of offset
        matches.sort(function (a, b) { return a.getOffset() - b.getOffset(); });
        for (var i = 0; i &lt; matches.length - 1; i++) {
            var match = matches[i], offset = match.getOffset(), matchedTextLength = match.getMatchedText().length, endIdx = offset + matchedTextLength;
            if (i + 1 &lt; matches.length) {
                // Remove subsequent matches that equal offset with current match
                if (matches[i + 1].getOffset() === offset) {
                    var removeIdx = matches[i + 1].getMatchedText().length &gt; matchedTextLength ? i : i + 1;
                    matches.splice(removeIdx, 1);
                    continue;
                }
                // Remove subsequent matches that overlap with the current match
                if (matches[i + 1].getOffset() &lt; endIdx) {
                    matches.splice(i + 1, 1);
                }
            }
        }
        return matches;
    };
<span id='Autolinker-method-removeUnwantedMatches'>    /**
</span>     * Removes matches for matchers that were turned off in the options. For
     * example, if {@link #hashtag hashtags} were not to be matched, we&#39;ll
     * remove them from the `matches` array here.
     *
     * Note: we *must* use all Matchers on the input string, and then filter
     * them out later. For example, if the options were `{ url: false, hashtag: true }`,
     * we wouldn&#39;t want to match the text &#39;#link&#39; as a HashTag inside of the text
     * &#39;google.com/#link&#39;. The way the algorithm works is that we match the full
     * URL first (which prevents the accidental HashTag match), and then we&#39;ll
     * simply throw away the URL match.
     *
     * @private
     * @param {Autolinker.match.Match[]} matches The array of matches to remove
     *   the unwanted matches from. Note: this array is mutated for the
     *   removals.
     * @return {Autolinker.match.Match[]} The mutated input `matches` array.
     */
    Autolinker.prototype.removeUnwantedMatches = function (matches) {
        if (!this.hashtag)
            utils_1.remove(matches, function (match) { return match.getType() === &#39;hashtag&#39;; });
        if (!this.email)
            utils_1.remove(matches, function (match) { return match.getType() === &#39;email&#39;; });
        if (!this.phone)
            utils_1.remove(matches, function (match) { return match.getType() === &#39;phone&#39;; });
        if (!this.mention)
            utils_1.remove(matches, function (match) { return match.getType() === &#39;mention&#39;; });
        if (!this.urls.schemeMatches) {
            utils_1.remove(matches, function (m) { return m.getType() === &#39;url&#39; &amp;&amp; m.getUrlMatchType() === &#39;scheme&#39;; });
        }
        if (!this.urls.wwwMatches) {
            utils_1.remove(matches, function (m) { return m.getType() === &#39;url&#39; &amp;&amp; m.getUrlMatchType() === &#39;www&#39;; });
        }
        if (!this.urls.tldMatches) {
            utils_1.remove(matches, function (m) { return m.getType() === &#39;url&#39; &amp;&amp; m.getUrlMatchType() === &#39;tld&#39;; });
        }
        return matches;
    };
<span id='Autolinker-method-parseText'>    /**
</span>     * Parses the input `text` looking for URLs, email addresses, phone
     * numbers, username handles, and hashtags (depending on the configuration
     * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
     * objects describing those matches.
     *
     * This method processes a **non-HTML string**, and is used to parse and
     * match within the text nodes of an HTML string. This method is used
     * internally by {@link #parse}.
     *
     * @private
     * @param {String} text The text to find matches within (depending on if the
     *   {@link #urls}, {@link #email}, {@link #phone},
     *   {@link #hashtag}, and {@link #mention} options are enabled). This must be a non-HTML string.
     * @param {Number} [offset=0] The offset of the text node within the
     *   original string. This is used when parsing with the {@link #parse}
     *   method to generate correct offsets within the {@link Autolinker.match.Match}
     *   instances, but may be omitted if calling this method publicly.
     * @return {Autolinker.match.Match[]} The array of Matches found in the
     *   given input `text`.
     */
    Autolinker.prototype.parseText = function (text, offset) {
        if (offset === void 0) { offset = 0; }
        offset = offset || 0;
        var matchers = this.getMatchers(), matches = [];
        for (var i = 0, numMatchers = matchers.length; i &lt; numMatchers; i++) {
            var textMatches = matchers[i].parseMatches(text);
            // Correct the offset of each of the matches. They are originally
            // the offset of the match within the provided text node, but we
            // need to correct them to be relative to the original HTML input
            // string (i.e. the one provided to #parse).
            for (var j = 0, numTextMatches = textMatches.length; j &lt; numTextMatches; j++) {
                textMatches[j].setOffset(offset + textMatches[j].getOffset());
            }
            matches.push.apply(matches, textMatches);
        }
        return matches;
    };
<span id='Autolinker-method-link'>    /**
</span>     * Automatically links URLs, Email addresses, Phone numbers, Hashtags,
     * and Mentions (Twitter, Instagram, Soundcloud) found in the given chunk of HTML. Does not link
     * URLs found within HTML tags.
     *
     * For instance, if given the text: `You should go to http://www.yahoo.com`,
     * then the result will be `You should go to
     * &amp;lt;a href=&quot;http://www.yahoo.com&quot;&amp;gt;http://www.yahoo.com&amp;lt;/a&amp;gt;`
     *
     * This method finds the text around any HTML elements in the input
     * `textOrHtml`, which will be the text that is processed. Any original HTML
     * elements will be left as-is, as well as the text that is already wrapped
     * in anchor (&amp;lt;a&amp;gt;) tags.
     *
     * @param {String} textOrHtml The HTML or text to autolink matches within
     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #hashtag}, and {@link #mention} options are enabled).
     * @return {String} The HTML, with matches automatically linked.
     */
    Autolinker.prototype.link = function (textOrHtml) {
        if (!textOrHtml) {
            return &quot;&quot;;
        } // handle `null` and `undefined`
        var matches = this.parse(textOrHtml), newHtml = [], lastIndex = 0;
        for (var i = 0, len = matches.length; i &lt; len; i++) {
            var match = matches[i];
            newHtml.push(textOrHtml.substring(lastIndex, match.getOffset()));
            newHtml.push(this.createMatchReturnVal(match));
            lastIndex = match.getOffset() + match.getMatchedText().length;
        }
        newHtml.push(textOrHtml.substring(lastIndex)); // handle the text after the last match
        return newHtml.join(&#39;&#39;);
    };
<span id='Autolinker-method-createMatchReturnVal'>    /**
</span>     * Creates the return string value for a given match in the input string.
     *
     * This method handles the {@link #replaceFn}, if one was provided.
     *
     * @private
     * @param {Autolinker.match.Match} match The Match object that represents
     *   the match.
     * @return {String} The string that the `match` should be replaced with.
     *   This is usually the anchor tag string, but may be the `matchStr` itself
     *   if the match is not to be replaced.
     */
    Autolinker.prototype.createMatchReturnVal = function (match) {
        // Handle a custom `replaceFn` being provided
        var replaceFnResult;
        if (this.replaceFn) {
            replaceFnResult = this.replaceFn.call(this.context, match); // Autolinker instance is the context
        }
        if (typeof replaceFnResult === &#39;string&#39;) {
            return replaceFnResult; // `replaceFn` returned a string, use that
        }
        else if (replaceFnResult === false) {
            return match.getMatchedText(); // no replacement for the match
        }
        else if (replaceFnResult instanceof html_tag_1.HtmlTag) {
            return replaceFnResult.toAnchorString();
        }
        else { // replaceFnResult === true, or no/unknown return value from function
            // Perform Autolinker&#39;s default anchor tag generation
            var anchorTag = match.buildTag(); // returns an Autolinker.HtmlTag instance
            return anchorTag.toAnchorString();
        }
    };
<span id='Autolinker-method-getMatchers'>    /**
</span>     * Lazily instantiates and returns the {@link Autolinker.matcher.Matcher}
     * instances for this Autolinker instance.
     *
     * @protected
     * @return {Autolinker.matcher.Matcher[]}
     */
    Autolinker.prototype.getMatchers = function () {
        if (!this.matchers) {
            var tagBuilder = this.getTagBuilder();
            var matchers = [
                new hashtag_matcher_1.HashtagMatcher({ tagBuilder: tagBuilder, serviceName: this.hashtag }),
                new email_matcher_1.EmailMatcher({ tagBuilder: tagBuilder }),
                new phone_matcher_1.PhoneMatcher({ tagBuilder: tagBuilder }),
                new mention_matcher_1.MentionMatcher({ tagBuilder: tagBuilder, serviceName: this.mention }),
                new url_matcher_1.UrlMatcher({ tagBuilder: tagBuilder, stripPrefix: this.stripPrefix, stripTrailingSlash: this.stripTrailingSlash, decodePercentEncoding: this.decodePercentEncoding })
            ];
            return (this.matchers = matchers);
        }
        else {
            return this.matchers;
        }
    };
<span id='Autolinker-method-getTagBuilder'>    /**
</span>     * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
     * if it does not yet exist.
     *
     * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that
     * Autolinker would normally generate, and then allow for modifications before returning it. For example:
     *
     *     var html = Autolinker.link( &quot;Test google.com&quot;, {
     *         replaceFn : function( match ) {
     *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance
     *             tag.setAttr( &#39;rel&#39;, &#39;nofollow&#39; );
     *
     *             return tag;
     *         }
     *     } );
     *
     *     // generated html:
     *     //   Test &lt;a href=&quot;http://google.com&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;google.com&lt;/a&gt;
     *
     * @return {Autolinker.AnchorTagBuilder}
     */
    Autolinker.prototype.getTagBuilder = function () {
        var tagBuilder = this.tagBuilder;
        if (!tagBuilder) {
            tagBuilder = this.tagBuilder = new anchor_tag_builder_1.AnchorTagBuilder({
                newWindow: this.newWindow,
                truncate: this.truncate,
                className: this.className
            });
        }
        return tagBuilder;
    };
<span id='Autolinker-property-version'>    /**
</span>     * The Autolinker version number in the form major.minor.patch
     *
     * Ex: 0.25.1
     */
    Autolinker.version = &#39;1.8.3&#39;;
<span id='Autolinker-AnchorTagBuilder'>    /**
</span>     * For backwards compatibility with Autolinker 1.x, the AnchorTagBuilder
     * class is provided as a static on the Autolinker class.
     */
    Autolinker.AnchorTagBuilder = anchor_tag_builder_1.AnchorTagBuilder;
<span id='Autolinker-HtmlTag'>    /**
</span>     * For backwards compatibility with Autolinker 1.x, the HtmlTag class is
     * provided as a static on the Autolinker class.
     */
    Autolinker.HtmlTag = html_tag_1.HtmlTag;
<span id='Autolinker-HtmlTag-property-matcher'>    /**
</span>     * For backwards compatibility with Autolinker 1.x, the Matcher classes are
     * provided as statics on the Autolinker class.
     */
    Autolinker.matcher = {
        Email: email_matcher_1.EmailMatcher,
        Hashtag: hashtag_matcher_1.HashtagMatcher,
        Matcher: matcher_1.Matcher,
        Mention: mention_matcher_1.MentionMatcher,
        Phone: phone_matcher_1.PhoneMatcher,
        Url: url_matcher_1.UrlMatcher
    };
<span id='Autolinker-HtmlTag-property-match'>    /**
</span>     * For backwards compatibility with Autolinker 1.x, the Match classes are
     * provided as statics on the Autolinker class.
     */
    Autolinker.match = {
        Email: email_match_1.EmailMatch,
        Hashtag: hashtag_match_1.HashtagMatch,
        Match: match_1.Match,
        Mention: mention_match_1.MentionMatch,
        Phone: phone_match_1.PhoneMatch,
        Url: url_match_1.UrlMatch
    };
    return Autolinker;
}());
exports.default = Autolinker;

//# sourceMappingURL=autolinker.js.map
</pre>
</body>
</html>
